import sys

def solve():
    import sys
    input = sys.stdin.buffer.read
    data = input().split()
    
    idx = 0
    t = int(data[idx])
    idx += 1
    results = []
    
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        p = list(map(int, data[idx:idx + n]))
        idx += n
        
        # For each number i (1-based), find its position in the permutation
        pos = [0] * (n + 1)  # pos[i] is the position of number i in the permutation
        for i in range(n):
            pos[p[i]] = i + 1  # 1-based position
        
        # Check if the permutation can be generated by the algorithm
        # We need to simulate the process for each number i from 1 to n
        # and check if the position chosen for i is valid according to the rules
        
        # For each step i (from 1 to n), we need to:
        # 1. Compute r_j for all j from 1 to n
        # 2. Compute count_t for all t from 1 to n
        # 3. Find the positions with maximum count_t
        # 4. Check if the position of i in the permutation is among those positions
        
        # We can optimize this by tracking for each i the positions that are still available
        # and the count of how many times each position is chosen for the remaining numbers
        
        # We will use a greedy approach to simulate the process
        # For each i from 1 to n:
        # - Find the positions that are still available
        # - For each j from 1 to n, compute r_j
        # - For each available position t, count how many j's have r_j = t
        # - Find the positions with maximum count
        # - Check if the position of i is among those positions
        
        # To optimize, we can precompute for each i the positions that are still available
        # and the count of how many j's have r_j = t
        
        # We will use a set to track available positions
        available = set(range(1, n + 1))
        
        valid = True
        for i in range(1, n + 1):
            # Compute r_j for all j from 1 to n
            # r_j is the minimum index >= j that is still available
            r = [0] * (n + 1)
            for j in range(1, n + 1):
                if j not in available:
                    r[j] = -1
                    continue
                # Find the minimum index >= j that is available
                for k in range(j, n + 1):
                    if k in available:
                        r[j] = k
                        break
            # Compute count_t for all t from 1 to n
            count = [0] * (n + 1)
            for j in range(1, n + 1):
                if r[j] != -1:
                    count[r[j]] += 1
            # Find the positions with maximum count
            max_count = -1
            candidates = []
            for t in range(1, n + 1):
                if count[t] > max_count:
                    max_count = count[t]
                    candidates = [t]
                elif count[t] == max_count:
                    candidates.append(t)
            # Now, check if the position of i is among the candidates
            # and if it is available
            pos_i = pos[i]
            if pos_i not in available:
                valid = False
                break
            if pos_i not in candidates:
                valid = False
                break
            # Remove the position from available
            available.remove(pos_i)
        
        results.append("Yes" if valid else "No")
    
    print("\n".join(results))

if __name__ == '__main__':
    solve()